<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Machine Learning," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="(1) 分类下面将介绍分类问题。我们将学习一种叫做逻辑回归(Logistic Regression)的算法，这也是目前最流行，使用最广泛的一种学习算法。下面是几个使用分类算法的例子：  Email的垃圾邮件分类问题：区分邮件是否为垃圾邮件 网上交易分类问题：是否为欺诈交易 肿瘤分类问题：区分肿瘤是恶性还是良性">
<meta name="keywords" content="Machine Learning">
<meta property="og:type" content="article">
<meta property="og:title" content="斯坦福机器学习课程 第三周">
<meta property="og:url" content="http://yoursite.com/2017/08/05/2017-08-05-Stanford-MachineLearning-week3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="(1) 分类下面将介绍分类问题。我们将学习一种叫做逻辑回归(Logistic Regression)的算法，这也是目前最流行，使用最广泛的一种学习算法。下面是几个使用分类算法的例子：  Email的垃圾邮件分类问题：区分邮件是否为垃圾邮件 网上交易分类问题：是否为欺诈交易 肿瘤分类问题：区分肿瘤是恶性还是良性">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2017-08-07T14:05:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="斯坦福机器学习课程 第三周">
<meta name="twitter:description" content="(1) 分类下面将介绍分类问题。我们将学习一种叫做逻辑回归(Logistic Regression)的算法，这也是目前最流行，使用最广泛的一种学习算法。下面是几个使用分类算法的例子：  Email的垃圾邮件分类问题：区分邮件是否为垃圾邮件 网上交易分类问题：是否为欺诈交易 肿瘤分类问题：区分肿瘤是恶性还是良性">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/05/2017-08-05-Stanford-MachineLearning-week3/"/>





  <title>斯坦福机器学习课程 第三周 | Hexo</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photos">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br />
            
            照片
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/05/2017-08-05-Stanford-MachineLearning-week3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">斯坦福机器学习课程 第三周</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-05T09:38:57+08:00">
                2017-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-分类"><a href="#1-分类" class="headerlink" title="(1) 分类"></a>(1) 分类</h2><p>下面将介绍分类问题。我们将学习一种叫做<strong>逻辑回归(Logistic Regression)</strong>的算法，这也是目前最流行，使用最广泛的一种学习算法。<br>下面是几个使用分类算法的例子：</p>
<ul>
<li>Email的垃圾邮件分类问题：区分邮件是否为垃圾邮件</li>
<li>网上交易分类问题：是否为欺诈交易</li>
<li>肿瘤分类问题：区分肿瘤是恶性还是良性<a id="more"></a>
在所有的这些问题中，我们想要预测的变量是$y​$，我们可以认为它取两个值：<code>0</code>或者<code>1</code>。<br>$$<br>y \in 0, 1<br>$$</li>
</ul>
<blockquote>
<p>0：“负类”（例如：良性肿瘤）</p>
<p>1：“正类”（例如：恶性肿瘤）</p>
</blockquote>
<p>现在研究的是只有两类（0和1）的分类问题，叫做<strong>二元分类</strong>问题。如果是更多类别的问题就是所谓的<strong>多类分类问题</strong>。</p>
<h3 id="二元分类"><a href="#二元分类" class="headerlink" title="二元分类"></a>二元分类</h3><p>对于这类问题我们可以使用<strong>逻辑回归算法(Logistic Regression)</strong>，这个算法的性质就是适用于$y$值为离散值的情况，并且它的输出值保证在0到1之间：<br>$$<br>0 \le h_\theta(x) \le 1<br>$$</p>
<blockquote>
<p>值得注意的是，<strong>逻辑回归算法</strong>是一个<strong>分类算法</strong>，即使它的名字里有<strong>回归</strong>，但我们也把它当成分类算法来使用。这里只是因为历史原因，才被这样称呼。</p>
</blockquote>
<h3 id="假设函数表达式"><a href="#假设函数表达式" class="headerlink" title="假设函数表达式"></a>假设函数表达式</h3><p>逻辑回归假设函数：<br>$$<br>h_\theta(x) = g(\theta^Tx)<br>$$<br>其中$g​$函数的表达式为：<br>$$<br>g(z) = \frac{1}{1+e^{-z}}<br>$$<br>这个函数被称为<strong>S型函数(Sigmoid function)</strong>，或者<strong>逻辑函数(Logistic function)</strong>。</p>
<p><strong>S型函数(Sigmoid function)</strong>的图形是这样的，顶部是随着$z$的增大而逐渐趋近于1，底部随着$z$的减小而逐渐趋近于0：</p>
    
<p>因此可以得到：<br>$$<br>\begin{eqnarray}<br> h_\theta(x) &amp;=&amp; g(\theta^Tx) \<br>&amp; = &amp; \frac{1}{1+e^{-\theta^Tx}}<br>\end{eqnarray}<br>$$<br>接下来我们要做的就是用参数$\theta$来拟合我们的数据。</p>
<h4 id="对假设函数的进一步理解"><a href="#对假设函数的进一步理解" class="headerlink" title="对假设函数的进一步理解"></a>对假设函数的进一步理解</h4><p><strong>假设函数的解释</strong>：</p>
<p>$h_\theta(x)$是对于新注入样本$x$的满足$y=1$的概率估计。<br>$$<br>h_\theta(x) = P(y = 1 | x; \theta)<br>$$</p>
<blockquote>
<p>这个式子代表着在给定的特征$x$的情况下，$y=1$的概率，其中参数为$\theta$。</p>
</blockquote>
<p>由于我们知道$y$的取值不是0就是1，因此当我们得到了$y=1$的概率时，$y=0$的概率就很容易得出：<br>$$<br>P(y=0 | x;0) = 1 - P(y=1|x;\theta)<br>$$</p>
<h3 id="决策边界-Decision-Boundary"><a href="#决策边界-Decision-Boundary" class="headerlink" title="决策边界(Decision Boundary)"></a>决策边界(Decision Boundary)</h3><p>逻辑回归假设函数：<br>$$<br>h_\theta(x) = g(\theta^Tx)  \<br>g(z) = \frac{1}{1+e^{-z}}<br>$$<br>对应的函数图象为：</p>

<p>更进一步来理解：</p>
<ul>
<li>如果$h_\theta(x) \ge 0.5$ 我们认为$y=1$</li>
<li>如果$h_\theta(x) \le 0.5$ 我们认为$y=0$</li>
</ul>
<p>根据图像可以得出：</p>
<ul>
<li>当$z \ge 0$时，$h_\theta(x) \ge 0.5$，满足$y=1$；</li>
<li>当$z \le 0$时，$h_\theta(x) \le 0.5$，满足$y=0$。</li>
</ul>
<p>即：</p>
<ul>
<li>当$\theta^Tx \ge 0$时，$y=1$；</li>
<li>当$\theta^Tx \le 0$时，$y=0$。</li>
</ul>
<p>当取$h_\theta(x) = 0$时，这条线则被称为<strong>决策边界(decision boundary)</strong>。</p>
<h2 id="2-Logistic回归模型"><a href="#2-Logistic回归模型" class="headerlink" title="(2) Logistic回归模型"></a>(2) Logistic回归模型</h2><h3 id="逻辑回归的代价函数"><a href="#逻辑回归的代价函数" class="headerlink" title="逻辑回归的代价函数"></a>逻辑回归的代价函数</h3><p>$$<br>Cost(h_\theta(x),y) =\left{\begin{array}{r}<br>-log(h_\theta(x)) ~~ \text{ if } y = 1 \<br>-log(1-h_\theta(x)) ~~\text{ if } y = 0<br>\end{array}<br>\right.<br>$$</p>
<table>
<thead>
<tr>
<th>$y=1$时</th>
<th>$y=0$时</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>现在这种形式的代价函数有很多有趣的性质：</p>
<ul>
<li>在$y=1$的情况下：<ul>
<li>如果$h_\theta(x)=1$，那么代价函数为0</li>
<li>如果$h_\theta(x) \rightarrow \infty$，那么代价函数趋近于$\infty$</li>
</ul>
</li>
<li>在$y=0$的情况下：<ul>
<li>如果$h_\theta(x) \rightarrow 1$，那么代价函数趋近于$\infty$</li>
<li>如果$h_\theta(x) = 0$，那么代价函数等于0</li>
</ul>
</li>
</ul>
<p>这就是我们所期望的效果：<strong>当假设函数和期望值越接近时，代价函数值越小，反之越大。</strong></p>
<h3 id="简化代价函数以及梯度下降"><a href="#简化代价函数以及梯度下降" class="headerlink" title="简化代价函数以及梯度下降"></a>简化代价函数以及梯度下降</h3><h4 id="简化单个样本的代价函数"><a href="#简化单个样本的代价函数" class="headerlink" title="简化单个样本的代价函数"></a>简化单个样本的代价函数</h4><p>对于单个样本的代价函数，我们可以把$y=0$和$y=1$的两种情况合二为一，写成一个统一的式子：<br>$$<br>Cost(h_\theta(x),y) = -ylog(h_\theta(x)) - (1-y)log(1-h_\theta(x))<br>$$</p>
<h4 id="拟合逻辑回归的参数-theta"><a href="#拟合逻辑回归的参数-theta" class="headerlink" title="拟合逻辑回归的参数$\theta$"></a>拟合逻辑回归的参数$\theta$</h4><p>问题的核心在于求解最小代价函数：</p>

<p>上图就是逻辑回归问题中最小化代价函数的方法，是通过梯度下降算法来实现。</p>
<p>对上图中的偏导数项展开后就是下面的形式：</p>

<p>如果你把上面的式子放到线性回归问题中进行对比的话，<strong>你会发现这个式子正是用来做线性回归梯度下降的。</strong></p>
<h3 id="高级优化"><a href="#高级优化" class="headerlink" title="高级优化"></a>高级优化</h3><p>利用一些技巧，可以使通过梯度下降进行逻辑回归的速度大大提高，这也将使得算法更加适合解决大型的机器学习问题。</p>
<h4 id="优化算法概念引入"><a href="#优化算法概念引入" class="headerlink" title="优化算法概念引入"></a>优化算法概念引入</h4><p>梯度下降并不是我们可以使用的唯一算法，下面是几种常用的算法：</p>
<ul>
<li><strong>梯度下降算法(Gradient descent)</strong></li>
<li><strong>共轭梯度法(Conjugate gradient)</strong></li>
<li><strong>变尺度法(BFGS)</strong></li>
<li><strong>限制变尺度法(L-BFGS)</strong></li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：</p>
<ul>
<li>不需要手动选择学习率$\alpha$<ul>
<li>所以对这些算法的一种思路是给出计算导数项和代价函数$J(θ)$的方法，可以认为是算法有一个智能的内部循环，这种智能的内部循环被称为<strong>线性搜索(line search)</strong>算法，它可以自动尝试不同的学习速率$\alpha$，并自动选择一个好的学习速率$\alpha$。因此它甚至可以在每次迭代时都选择不同的学习速率，那么你就不需要自己选择$\alpha$了。</li>
</ul>
</li>
<li>通常情况下收敛速度比梯度下降算法更快<ul>
<li>这些算法实际上在做更复杂的事情，而不仅仅是选择一个好的学习速率$\alpha$，所以他们往往最终收敛的远远快于梯度下降。</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>比梯度下降法复杂多了<ul>
<li>如果你不是数值计算方面的专家，不建议你亲自去写共轭梯度法、BFGS和L-BFGS，而是去使用一些现成的库。实际上Octave和Matlab都有很理想的库来实现这些先进的优化算法。值得一提的是，这些算法在不同语言上的实现，是有差别的，有的语言上的库可能会表现的不太好。所以建议对比选择合适的实现。</li>
</ul>
</li>
</ul>
<h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>现在举例说明如何使用这些算法。假设你有一个包含两个参数的问题：</p>

<p>对于上图中的代价函数，我们可以求得当$\theta_1 = 5$, $\theta_2 = 5$时，$J(\theta)$的值最小。</p>
<p>下面是使用Octave程序来计算$\theta_1$和$\theta_2$。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function [jVal, gradient] = costFunction(theta)</span><br><span class="line">jVal = (theta(1)-5)^2 + (theta(2)-5)^2;</span><br><span class="line">gradient = zeros(2,1);</span><br><span class="line">gradient(1) = 2*(theta(1)-5);</span><br><span class="line">gradient(2) = 2*(theta(2)-5);</span><br></pre></td></tr></table></figure>
<p>上面这段代码定义了一个函数<code>costFunction(theta)</code>，参数是一个<code>theta</code>向量，包含$\theta_1$和$θ_2$，返回值是<code>jVal</code>和<code>gradient</code>。通过函数的定义，我们可以看出来<code>jVal</code>表示的是代价函数$J(θ)=(\theta_1 - 5)^2 + (\theta_2 - 5)^2$。<code>gradient</code>是一个列量，其中两个值分别代表对$\theta_2$和$\theta_2$的偏导。</p>
<p>接下来，调用高级优化函数<code>fminunc</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options = optimset(&apos;GradObj&apos;, &apos;on&apos;, &apos;MaxIter&apos;, &apos;100&apos;);</span><br><span class="line">initialTheta = zeros(2,1);</span><br><span class="line">[optTheta, functionVal, exitFlag] = fminunc(@costFunction, initialTheta, options);</span><br></pre></td></tr></table></figure>
<p><code>fminunc</code>表示Octave里无约束最小化函数，调用这个函数时，需要传入一个存有配置信息的变量<code>options</code>。上面的代码中，我们的设置项中<code>&#39;GradObj&#39;, &#39;on&#39;,</code>代表设置梯度目标参数为打开状态(on)，这也意味着你现在确实要给这个算法提供一个梯度。<code>&#39;MaxIter&#39;, &#39;100&#39;</code>代表设置最大迭代次数为100次。<code>initialTheta</code>代表我们给出的一个$θ$的猜测初始值。</p>
<p>然后我们调用<code>fminunc</code>这个函数，传入三个参数，其中第一个参数<code>@costFunction</code>这里的<code>@</code>符号代表指向之前我们定义的<code>costFunction</code>函数的指针。后面两个参数分别是我们定义的$\theta$初始值和配置信息<code>options</code>。</p>
<p>当我们调用这个<code>fminunc</code>函数时，它会自动的从众多高级优化算法中挑选一个来使用(你也可以把它当做一个可以自动选择合适的学习速率$\alpha$的梯度下降算法)。</p>
<p>最终我们会得到三个返回值，分别是满足最小化代价函数$J(θ)$的$θ$值<code>optTheta</code>，<code>costFunction</code>中定义的<code>jVal</code>的值<code>functionVal</code>，以及标记是否已经收敛的状态值<code>exitFlag</code>，如果已收敛，标记为<code>1</code>，否则为<code>0</code>。</p>
    
<h4 id="在逻辑回归中使用优化算法"><a href="#在逻辑回归中使用优化算法" class="headerlink" title="在逻辑回归中使用优化算法"></a>在逻辑回归中使用优化算法</h4><p>上面的例子是一个简单的二次函数中使用优化算法的例子，下面介绍一些在逻辑回归中使用这些算法：</p>
    
<p>上图就是逻辑回归问题的代价函数的求解代码。可以看到大体流程和之前的例子是一致的，只需要把相应的计算<code>jVal</code>以及各个<code>gradient</code>的代码，按照逻辑回归的规则填写完整即可。</p>
<blockquote>
<p>使用了这些复杂的优化算法之后，虽然它将使得调试变得更为困难，但是这些算法的速度远远大于普通的梯度下降算法的速度，因此可以用来处理很大的机器学习问题的时候，可以使用这些高级算法，而不是梯度下降算法。</p>
</blockquote>
<h2 id="3-多类别分类问题：一对多"><a href="#3-多类别分类问题：一对多" class="headerlink" title="(3) 多类别分类问题：一对多"></a>(3) 多类别分类问题：一对多</h2><h3 id="一对多-one-vs-all-分类问题"><a href="#一对多-one-vs-all-分类问题" class="headerlink" title="一对多(one-vs-all)分类问题"></a>一对多(one-vs-all)分类问题</h3><p>先看这样一些例子：</p>
<ul>
<li>邮件分类器自动将邮件按照以下标签分类：工作，朋友，家庭，兴趣</li>
<li>医学根据病人的得病类型分类：没有病，感冒，流感</li>
<li>天气预报根据天气类型分类：晴天，多云，雨天，雪天</li>
</ul>
<p>我们可以分别对这些类别打上数值标签，比如天气分类中：晴天代表<code>y=1</code>，多云代表<code>y=2</code>，雨天代表<code>y=3</code>，雪天代表<code>y=4</code>。</p>
<p>以上这些例子都属于多类别分类问题。</p>
<p>对于多分类问题，我们可以把它看作是多个二分类问题，这样我们就得到了多个分类器，通过这些分类器来估算给出$x$和$\theta$时，$y=i$的概率：<br>$$<br>h_\theta^{(i)}=P(y=i | x; \theta)  ~~~  (i = 1,2,3)<br>$$<br>总之，现在我要做的就是训练这个逻辑回归分类器$h_\theta^{(i)}(x)$，其中$i$对应每一个可能的$y=i$。</p>
<p>最后，为了做出预测，我们给定一个新的输入值$x$，用来做预测，我们要做的就是在我们的多个分类器里输入$x$，然后我们选择一个让$h_θ^{(i)}(x)$最大的$i$，这就是预测出的类别。</p>
<h2 id="4-正则化：解决过拟合问题"><a href="#4-正则化：解决过拟合问题" class="headerlink" title="(4) 正则化：解决过拟合问题"></a>(4) 正则化：解决过拟合问题</h2><blockquote>
<p>机器学习模型需要拥有很好地泛化能力来适应训练集中没有出现过的新样本。正则化是一个有助于预防过拟合的有效办法。</p>
</blockquote>
<h3 id="解决过拟合问题"><a href="#解决过拟合问题" class="headerlink" title="解决过拟合问题"></a>解决过拟合问题</h3><blockquote>
<p>到现在为止我已经学习了几种不同的学习算法，包括线性回归和逻辑回归，它们能够有效地解决许多问题，但是当应用到某些特定的及其学习应用时，会遇到<strong>过度拟合(over-fitting)</strong>的问题，可能导致效果很差。</p>
<p>接下来我将谈论一种称为<strong>正则化(regularization)</strong>的技术，它可以改善或者减少过度拟合问题，以使学习算法更好实现。</p>
</blockquote>
<h4 id="梯度下降中的过拟合问题"><a href="#梯度下降中的过拟合问题" class="headerlink" title="梯度下降中的过拟合问题"></a>梯度下降中的过拟合问题</h4><p>让我们继续使用那个线性回归来预测房价的例子。</p>
<h5 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h5><p>我们通过建立以住房面积为自变量的函数来预测房价，我们可以对该数据做线性回归：</p>
    
<p>但这不是一个很好的模型，因为随着房子面积增大，住房价格的变化趋势趋于稳定，或者往右越平缓。所以这个算法没有很好地拟合训练数据。</p>
<p>我们把这个问题称为<strong>欠拟合(under fitting)</strong>，这个问题的另一个术语叫做<strong>高偏差(High bias)</strong>。</p>
<h5 id="刚好合适"><a href="#刚好合适" class="headerlink" title="刚好合适"></a>刚好合适</h5><p>当我们加入一个二次项，在这组数据中，我们用二次函数来拟合它：</p>
    
<p>事实证明这个拟合效果很好。</p>
<h5 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h5><p>另一个极端情况是，如果我们拟合一个四次多项式，因此在这里我们用五个参数来拟合这五个训练样本，你可以得到看上去像这样的一条曲线：</p>
    
<p>一方面似乎对训练数据做了一个很好的拟合，因为这条曲线通过了所有的训练实例。但是，这仍然是一条扭曲的曲线。它不停上下波动，因此事实上，我们并不认为它是一个预测房价的好模型。</p>
<p>这个问题我们把他叫做<strong>过度拟合(over fitting)</strong>，另一个描述该问题的术语是<strong>高方差(variance)</strong>。</p>
<p>介于<strong>高偏差</strong>和<strong>高方差</strong>这两者之间的情况叫做<strong>“刚好合适”</strong>。</p>
<p>概括地说，过拟合的问题将会在变量过多的时候发生，这种时候训练出的方程总能很好的拟合训练数据，所以你的代价函数实际上可能非常接近于0，甚至就是0。但是这会导致这种模型无法<strong>泛化</strong>到新的数据样本中，以至于无法预测新样本价格。</p>
<p>在这里术语<strong>“泛化(generalize)”</strong>指的是一个假设模型能够应用到新样本的能力。</p>
<h4 id="逻辑回归中的过拟合问题"><a href="#逻辑回归中的过拟合问题" class="headerlink" title="逻辑回归中的过拟合问题"></a>逻辑回归中的过拟合问题</h4><p>类似的方法同样可以应用到<strong>逻辑回归</strong>。</p>
<h5 id="解决过拟合问题-1"><a href="#解决过拟合问题-1" class="headerlink" title="解决过拟合问题"></a>解决过拟合问题</h5><p>当我们有过多变量，同时只有非常少的训练数据时，就会出现过度拟合的问题。</p>
<p>为了解决过度拟合问题，有两种方法：</p>
<ol>
<li>要尽量减少选取的变量的数量。<ul>
<li>具体而言我们可以人工检测变量的条目，保留重要的特征，舍弃无用的特征</li>
<li>模型选择算法（后面的课程会提到）</li>
</ul>
</li>
<li>正则化<ul>
<li>保留所有的特征变量，但是通过减少参数$θ_j$的数量级或值的大小。</li>
</ul>
</li>
</ol>
<p><strong>正则化</strong>相关的知识点将在接下来的内容中介绍。</p>
<h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>正则化的思路就是，如果我们的参数值对应一个较小的值，那么往往会得到一个形式更简单的假设函数，就能够减少代价函数的均方误差。通常情况下来讲，参数值减少的越多，函数越光滑，就不易发生过拟合的问题。</p>
<h4 id="正则化优化的目标"><a href="#正则化优化的目标" class="headerlink" title="正则化优化的目标"></a>正则化优化的目标</h4><p>我们正则化之后的代价函数如下：<br>$$<br>J(\theta) = \frac{1}{2m}\left[<br>\sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda \sum_{j=1}^n \theta_j^2<br>\right]<br>$$<br>在后面的正规化项中的$\lambda$我们称为<strong>正规化参数</strong>。</p>
<p>$\lambda$要做的就是控制在两个不同的目标中的一个平衡关系：</p>
<ul>
<li>第一个目标就是：我们想要训练使假设函数更好的拟合训练数据。</li>
<li>第二个目标就是：我们想要保持参数值较小。</li>
</ul>
<p>参数$\lambda$就是用来控制这两者之间的平衡，目标就是平衡<strong>拟合训练</strong>的目的和<strong>保持参数值较小</strong>的目的。（即欠拟合和过拟合的平衡）</p>
<p>正规化线性回归中，如果正规化参数值被设定为非常大，那么假设函数将会变为：<br>$$<br>h_\theta(x) = \theta_0<br>$$<br>对于数据来说这就是<strong>欠拟合(under-fitting)</strong>。因此为了使正则化运作的良好，我们应该去选择一个不错的正则化参数$\lambda$，并且当我们讲到多重选择时，我们将会介绍一种方法来<strong>自动选择正则化参数$\lambda$</strong>。这就是高度正则化的思路。</p>
<h3 id="正则化线性回归"><a href="#正则化线性回归" class="headerlink" title="正则化线性回归"></a>正则化线性回归</h3><p>对于线性回归的求解，我们之前推导了两种学习算法：一种基于梯度下降、一种基于正规方程。接下来我们会把它们推广到正则化线性回归中去。</p>
<h4 id="基于梯度下降"><a href="#基于梯度下降" class="headerlink" title="基于梯度下降"></a>基于梯度下降</h4><p>​        <strong>Repeat{</strong><br>$$<br>\begin{array}{l}<br>\theta_0 := \theta_0 - \alpha \frac{1}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)}  \<br>\theta_j := \theta_j - \alpha [ \frac{1}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)} +\frac{\lambda}{m}\theta_j ] ~~~ (j = 1, 2, 3, …, n)<br>\end{array}<br>$$<br>​                <strong>}</strong></p>
<p>对于上面式子中第二项可以改写成这种形式：</p>
    
<p>当我们使用正则化线性回归时，我们实际上做的就是在每一个被正则化的参数$θ_j$上乘以了一个比1小一点点的数字，然后执行跟以前一样的更新。</p>
<h4 id="基于正规方程"><a href="#基于正规方程" class="headerlink" title="基于正规方程"></a>基于正规方程</h4><p>取$J$关于各个参数的偏导数，并令他们等于0，然后通过一些数学推导可以得到这样的式子：<br>$$<br>\theta = (X^TX + \lambda\left[<br>\begin{array}{c}<br>0 &amp; 0 &amp; … &amp; 0 \<br>0 &amp; 1 \<br>… &amp; … &amp; … &amp; \<br>0 &amp; 0 &amp; … &amp; 1<br>\end{array}<br>\right])^{-1} X^T y<br>$$<br>其中正则化矩阵左上角的元素是0，其余对角线元素都是1，剩下的元素也都是0。矩阵的维度是$(n + 1) \times (n + 1)$。</p>
<h3 id="不可逆问题（-选学）"><a href="#不可逆问题（-选学）" class="headerlink" title="不可逆问题（*选学）"></a>不可逆问题（*选学）</h3><p>在正规方程中，考虑$m$（即样本总数）小于等于特征数量$n$：<br>$$<br>m \le n<br>$$<br>如果样本数量比特征数量小的话，那么这个矩阵$X^TX$将是<strong>不可逆</strong>的或<strong>奇异(singular)</strong>的。</p>
<p>幸运的是，正规化也为我们解决了这个问题，具体地说，只要正则参数是严格大于0的：<br>$$<br>\lambda &gt; 0<br>$$<br>实际上是可以证明<br>$$<br>X^TX + \lambda\left[<br>\begin{array}{c}<br>0 &amp; 0 &amp; … &amp; 0 \<br>0 &amp; 1 \<br>… &amp; … &amp; … &amp; \<br>0 &amp; 0 &amp; … &amp; 1<br>\end{array}<br>\right]<br>$$<br>这个矩阵是可逆的。</p>
<p>因此，使用正则化还可以解决一些$X^TX$不可逆的问题。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Machine-Learning/" rel="tag"># Machine Learning</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/04/2017-08-04-Stanford-MachineLearning-week2/" rel="next" title="斯坦福机器学习课程 第二周">
                <i class="fa fa-chevron-left"></i> 斯坦福机器学习课程 第二周
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/07/2017-08-07-Octave-LinearRegression/" rel="prev" title="Octave实现线性回归模型">
                Octave实现线性回归模型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.jpg"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/El-Chiang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/5096104875?refer_flag=1005055010_&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-分类"><span class="nav-number">1.</span> <span class="nav-text">(1) 分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二元分类"><span class="nav-number">1.1.</span> <span class="nav-text">二元分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#假设函数表达式"><span class="nav-number">1.2.</span> <span class="nav-text">假设函数表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对假设函数的进一步理解"><span class="nav-number">1.2.1.</span> <span class="nav-text">对假设函数的进一步理解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#决策边界-Decision-Boundary"><span class="nav-number">1.3.</span> <span class="nav-text">决策边界(Decision Boundary)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Logistic回归模型"><span class="nav-number">2.</span> <span class="nav-text">(2) Logistic回归模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑回归的代价函数"><span class="nav-number">2.1.</span> <span class="nav-text">逻辑回归的代价函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简化代价函数以及梯度下降"><span class="nav-number">2.2.</span> <span class="nav-text">简化代价函数以及梯度下降</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简化单个样本的代价函数"><span class="nav-number">2.2.1.</span> <span class="nav-text">简化单个样本的代价函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拟合逻辑回归的参数-theta"><span class="nav-number">2.2.2.</span> <span class="nav-text">拟合逻辑回归的参数$\theta$</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高级优化"><span class="nav-number">2.3.</span> <span class="nav-text">高级优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优化算法概念引入"><span class="nav-number">2.3.1.</span> <span class="nav-text">优化算法概念引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点"><span class="nav-number">2.3.2.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用实例"><span class="nav-number">2.3.3.</span> <span class="nav-text">使用实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在逻辑回归中使用优化算法"><span class="nav-number">2.3.4.</span> <span class="nav-text">在逻辑回归中使用优化算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-多类别分类问题：一对多"><span class="nav-number">3.</span> <span class="nav-text">(3) 多类别分类问题：一对多</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一对多-one-vs-all-分类问题"><span class="nav-number">3.1.</span> <span class="nav-text">一对多(one-vs-all)分类问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-正则化：解决过拟合问题"><span class="nav-number">4.</span> <span class="nav-text">(4) 正则化：解决过拟合问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决过拟合问题"><span class="nav-number">4.1.</span> <span class="nav-text">解决过拟合问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#梯度下降中的过拟合问题"><span class="nav-number">4.1.1.</span> <span class="nav-text">梯度下降中的过拟合问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#欠拟合"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">欠拟合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#刚好合适"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">刚好合适</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#过拟合"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">过拟合</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑回归中的过拟合问题"><span class="nav-number">4.1.2.</span> <span class="nav-text">逻辑回归中的过拟合问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#解决过拟合问题-1"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">解决过拟合问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代价函数"><span class="nav-number">4.2.</span> <span class="nav-text">代价函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#正则化优化的目标"><span class="nav-number">4.2.1.</span> <span class="nav-text">正则化优化的目标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则化线性回归"><span class="nav-number">4.3.</span> <span class="nav-text">正则化线性回归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于梯度下降"><span class="nav-number">4.3.1.</span> <span class="nav-text">基于梯度下降</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于正规方程"><span class="nav-number">4.3.2.</span> <span class="nav-text">基于正规方程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可逆问题（-选学）"><span class="nav-number">4.4.</span> <span class="nav-text">不可逆问题（*选学）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-paw"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
